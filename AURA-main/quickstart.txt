AURA Compression Quick Start Guide

Copyright (c) 2025 Todd James Hendricks
Licensed under Apache License 2.0
Patent Pending - Application No. 19/366,538

--------------------------------------------------------------------------------

PYTHON QUICK START

Basic compression:

  from aura_compression import ProductionHybridCompressor

  compressor = ProductionHybridCompressor(enable_aura=True)

  text = "I cannot browse the internet."
  compressed, method, metadata = compressor.compress(text)

  print(f"Original: {len(text)} bytes")
  print(f"Compressed: {len(compressed)} bytes")
  print(f"Ratio: {metadata['ratio']:.2f}:1")

  decompressed = compressor.decompress(compressed)
  assert decompressed == text

Client SDK:

  from packages.client_sdk import ClientSDK

  client = ClientSDK(template_store_path="templates.json")

  payload = b'\x00...'
  text = client.decode_payload(payload)

  text, metadata = client.decode_payload(payload, return_metadata=True)
  print(f"Method: {metadata['method']}")

Server SDK:

  from packages.server_sdk import ServerSDK

  server = ServerSDK(
      enable_aura=True,
      enable_audit_logging=True,
      session_id="session_123"
  )

  compressed, method, metadata = server.compress("Hello, world!")

  intent = server.classify_intent(compressed)
  is_safe = server.screen_fast_path(compressed)

--------------------------------------------------------------------------------

NODE.JS QUICK START

Basic compression:

  const { Compressor } = require('@aura/compression');

  const compressor = new Compressor({ enableAura: true });

  const text = "I cannot browse the internet.";
  const result = compressor.compress(text);

  console.log(`Original: ${result.metadata.originalSize} bytes`);
  console.log(`Compressed: ${result.payload.length} bytes`);
  console.log(`Ratio: ${result.metadata.ratio.toFixed(2)}:1`);

  const decompressed = compressor.decompress(result.payload);
  console.assert(decompressed === text);

Client SDK:

  const { ClientSDK } = require('@aura/compression');

  const client = new ClientSDK({
    templateStorePath: 'templates.json'
  });

  const payload = Buffer.from([0x00, ...]);
  const text = client.decodePayload(payload);

  const result = client.decodePayload(payload, true);
  console.log(`Method: ${result.metadata.method}`);

Server SDK:

  const { ServerSDK } = require('@aura/compression');

  const server = new ServerSDK({
    enableAura: true,
    enableAuditLogging: true,
    sessionId: 'session_123'
  });

  const result = server.compress("Hello, world!");

  const intent = server.classifyIntent(result.payload);
  const isSafe = server.screenFastPath(result.payload);

--------------------------------------------------------------------------------

RUST QUICK START

Basic compression:

  use aura_compression::{Compressor, CompressionMethod};

  fn main() -> Result<(), Box<dyn std::error::Error>> {
      let compressor = Compressor::new(true, None, false, None, None);

      let text = "I cannot browse the internet.";
      let (payload, method, metadata) = compressor.compress(text, None, None)?;

      println!("Original: {} bytes", metadata.original_size);
      println!("Compressed: {} bytes", payload.len());
      println!("Ratio: {:.2}:1", metadata.ratio);

      let decompressed = compressor.decompress(&payload)?;
      assert_eq!(text, decompressed);

      Ok(())
  }

Client SDK:

  use aura_compression::ClientSDK;

  let client = ClientSDK::new(Some("templates.json".to_string()), None);

  let payload = vec![0x00, ...];
  let (text, _) = client.decode_payload(&payload, false)?;

  let (text, metadata) = client.decode_payload(&payload, true)?;
  if let Some(meta) = metadata {
      println!("Method: {}", meta.method);
  }

Server SDK:

  use aura_compression::ServerSDK;

  let server = ServerSDK::new(
      true,
      None,
      true,
      Some("session_123".to_string()),
      None,
  );

  let (payload, method, metadata) = server.compress("Hello, world!", None, None)?;

  let intent = server.classify_intent(&payload);
  let is_safe = server.screen_fast_path(&payload);

--------------------------------------------------------------------------------

DOCKER QUICK START

Run server:

  docker run -d \
    --name aura-server \
    -p 8765:8765 \
    -v $(pwd)/data:/data \
    -v $(pwd)/logs:/logs \
    -e AURA_ENABLE_AUDIT=true \
    aura/compression:latest

Use Docker Compose:

  docker-compose up -d

Check status:

  docker-compose ps
  docker-compose logs -f aura-server

Run compression test:

  docker run --rm aura/compression:latest aura-compress --help

Interactive shell:

  docker run -it --rm aura/compression:latest /bin/bash

--------------------------------------------------------------------------------

CLI TOOLS (RUST)

Compress file:

  aura-compress input.txt -o compressed.aura

Decompress file:

  aura-decompress compressed.aura -o output.txt

Start server:

  aura-server --port 8765 --enable-audit

Show help:

  aura-compress --help
  aura-decompress --help
  aura-server --help

--------------------------------------------------------------------------------

WEBSOCKET SERVER (PYTHON)

Start server:

  python production_websocket_server.py

Connect with client:

  import asyncio
  import websockets

  async def test_client():
      uri = "ws://localhost:8765"
      async with websockets.connect(uri) as websocket:
          await websocket.send("Hello, server!")
          response = await websocket.recv()
          print(f"Received: {response}")

  asyncio.run(test_client())

--------------------------------------------------------------------------------

COMPRESSION METHODS

Binary Semantic (0x00):
  - Template-based compression
  - 95:1 compression ratio
  - Best for repeated patterns
  - Example: "I cannot browse the internet."

AuraLite (0x01):
  - Proprietary fallback compression
  - 5:1 compression ratio
  - No external dependencies
  - Used when no template matches

BRIO (0x02):
  - Multi-template compression
  - 12:1 compression ratio
  - Advanced pattern matching
  - Best for complex messages

AURA-Lite (0x03):
  - Template + dictionary compression
  - 8:1 compression ratio
  - Hybrid approach
  - Best for mixed content

Uncompressed (0xFF):
  - No compression applied
  - 1:1 ratio
  - Safety fallback
  - Used when compression doesn't help

--------------------------------------------------------------------------------

TEMPLATE LIBRARY

Core templates: 120 templates
Discovered templates: 487 templates
Total templates: 607 templates
Coverage: 87.1% on AI conversations
Target coverage: 72%

Common templates:

  ID 0: "I don't have access to {0}. {1}"
  ID 1: "I cannot {0}."
  ID 10: "The {0} of {1} is {2}."
  ID 11: "{0} is {1}."

Custom templates:

  Python:
    compressor.template_library.add(1000, "Custom template: {0}")

  Node.js:
    compressor.registerTemplate(1000, "Custom template: {0}")

  Rust:
    compressor.register_template(1000, "Custom template: {0}".to_string())

--------------------------------------------------------------------------------

NEXT STEPS

For more information, see:
  - usage.txt for detailed usage examples
  - api.txt for complete API documentation
  - docker.txt for Docker deployment guide
  - performance.txt for performance tuning
