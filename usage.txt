AURA Compression Usage Guide

Copyright (c) 2025 Todd James Hendricks
Licensed under Apache License 2.0
Patent Pending - Application No. 19/366,538

--------------------------------------------------------------------------------

BASIC COMPRESSION

Python:

  from aura_compression import ProductionHybridCompressor

  compressor = ProductionHybridCompressor(enable_aura=True)

  text = "I cannot browse the internet."
  compressed, method, metadata = compressor.compress(text)

  decompressed = compressor.decompress(compressed)

Node.js:

  const { Compressor } = require('@aura/compression');

  const compressor = new Compressor({ enableAura: true });

  const text = "I cannot browse the internet.";
  const result = compressor.compress(text);

  const decompressed = compressor.decompress(result.payload);

Rust:

  use aura_compression::Compressor;

  let compressor = Compressor::new(true, None, false, None, None);

  let text = "I cannot browse the internet.";
  let (payload, method, metadata) = compressor.compress(text, None, None)?;

  let decompressed = compressor.decompress(&payload)?;

--------------------------------------------------------------------------------

TEMPLATE-BASED COMPRESSION

Register custom template:

  Python:
    compressor.template_library.add(1000, "Error: {0} at {1}")

  Node.js:
    compressor.registerTemplate(1000, "Error: {0} at {1}")

  Rust:
    compressor.register_template(1000, "Error: {0} at {1}".to_string())

Compress with template:

  Python:
    text = "Error: File not found at /path/to/file"
    compressed, method, metadata = compressor.compress(
        text,
        template_id=1000,
        slots=["File not found", "/path/to/file"]
    )

  Node.js:
    const text = "Error: File not found at /path/to/file";
    const result = compressor.compress(
        text,
        1000,
        ["File not found", "/path/to/file"]
    );

  Rust:
    let text = "Error: File not found at /path/to/file";
    let (payload, method, metadata) = compressor.compress(
        text,
        Some(1000),
        Some(vec![
            "File not found".to_string(),
            "/path/to/file".to_string()
        ])
    )?;

--------------------------------------------------------------------------------

CLIENT SDK USAGE

Decode server payloads:

  Python:
    from packages.client_sdk import ClientSDK

    client = ClientSDK(template_store_path="templates.json")

    payload = receive_from_server()
    text = client.decode_payload(payload)

    text, metadata = client.decode_payload(payload, return_metadata=True)
    print(f"Method: {metadata['method']}")
    print(f"Template IDs: {metadata['template_ids']}")

  Node.js:
    const { ClientSDK } = require('@aura/compression');

    const client = new ClientSDK({
      templateStorePath: 'templates.json'
    });

    const payload = receiveFromServer();
    const text = client.decodePayload(payload);

    const result = client.decodePayload(payload, true);
    console.log(`Method: ${result.metadata.method}`);
    console.log(`Template IDs: ${result.metadata.templateIds}`);

  Rust:
    use aura_compression::ClientSDK;

    let client = ClientSDK::new(Some("templates.json".to_string()), None);

    let payload = receive_from_server();
    let (text, _) = client.decode_payload(&payload, false)?;

    let (text, metadata) = client.decode_payload(&payload, true)?;
    if let Some(meta) = metadata {
        println!("Method: {}", meta.method);
        println!("Template IDs: {:?}", meta.template_ids);
    }

Compress client messages:

  Python:
    compressed, method, metadata = client.compress("Hello, server!")
    send_to_server(compressed)

  Node.js:
    const result = client.compress("Hello, server!");
    sendToServer(result.payload);

  Rust:
    let (payload, method, metadata) = client.compress("Hello, server!", None, None)?;
    send_to_server(&payload);

--------------------------------------------------------------------------------

SERVER SDK USAGE

Initialize with audit logging:

  Python:
    from packages.server_sdk import ServerSDK

    server = ServerSDK(
        enable_aura=True,
        enable_audit_logging=True,
        session_id="session_123",
        user_id="user_456"
    )

  Node.js:
    const { ServerSDK } = require('@aura/compression');

    const server = new ServerSDK({
      enableAura: true,
      enableAuditLogging: true,
      sessionId: 'session_123',
      userId: 'user_456'
    });

  Rust:
    use aura_compression::ServerSDK;

    let server = ServerSDK::new(
        true,
        None,
        true,
        Some("session_123".to_string()),
        Some("user_456".to_string())
    );

Fast-path processing:

  Python:
    payload = receive_from_client()

    metadata = server.extract_metadata(payload)
    intent = server.classify_intent(payload)
    is_safe = server.screen_fast_path(payload)

    if is_safe and intent == "simple_query":
        response = handle_fast_path(metadata)
    else:
        full_text = server.decompress(payload)
        response = handle_full_processing(full_text)

  Node.js:
    const payload = receiveFromClient();

    const metadata = server.extractMetadata(payload);
    const intent = server.classifyIntent(payload);
    const isSafe = server.screenFastPath(payload);

    if (isSafe && intent === 'simple_query') {
        const response = handleFastPath(metadata);
    } else {
        const fullText = server.decompress(payload);
        const response = handleFullProcessing(fullText);
    }

  Rust:
    let payload = receive_from_client();

    let metadata = server.extract_metadata(&payload);
    let intent = server.classify_intent(&payload);
    let is_safe = server.screen_fast_path(&payload);

    if is_safe && intent == "simple_query" {
        let response = handle_fast_path(&metadata);
    } else {
        let full_text = server.decompress(&payload)?;
        let response = handle_full_processing(&full_text);
    }

--------------------------------------------------------------------------------

WEBSOCKET SERVER

Start server (Python):

  python production_websocket_server.py

Custom configuration:

  import asyncio
  from production_websocket_server import ProductionAuraServer

  async def main():
      server = ProductionAuraServer(
          host="0.0.0.0",
          port=8765,
          enable_audit=True,
          session_id="custom_session"
      )
      await server.start()

  asyncio.run(main())

Client connection:

  import asyncio
  import websockets

  async def client():
      uri = "ws://localhost:8765"
      async with websockets.connect(uri) as websocket:
          await websocket.send("Hello, server!")
          response = await websocket.recv()
          print(f"Received: {response}")

  asyncio.run(client())

--------------------------------------------------------------------------------

TEMPLATE MANAGEMENT

Load templates from file:

  Python:
    compressor = ProductionHybridCompressor(
        template_store_path="templates.json"
    )

  Node.js:
    const compressor = new Compressor({
      templateStorePath: 'templates.json'
    });

  Rust:
    let compressor = Compressor::new(
        true,
        Some("templates.json".to_string()),
        false,
        None,
        None
    );

Template file format (JSON):

  {
    "templates": {
      "0": {
        "pattern": "I don't have access to {0}. {1}",
        "category": "limitations"
      },
      "1": {
        "pattern": "I cannot {0}.",
        "category": "limitations"
      },
      "1000": {
        "pattern": "Custom template: {0}",
        "category": "custom"
      }
    }
  }

List all templates:

  Python:
    templates = compressor.template_library.list_templates()
    for template_id, pattern in templates.items():
        print(f"{template_id}: {pattern}")

  Node.js:
    const templates = compressor.listTemplates();
    for (const [id, pattern] of Object.entries(templates)) {
      console.log(`${id}: ${pattern}`);
    }

  Rust:
    let templates = compressor.list_templates();
    for (id, pattern) in templates {
        println!("{}: {}", id, pattern);
    }

--------------------------------------------------------------------------------

COMPRESSION METADATA

Access compression metadata:

  Python:
    compressed, method, metadata = compressor.compress(text)

    print(f"Original size: {metadata['original_size']}")
    print(f"Compressed size: {metadata['compressed_size']}")
    print(f"Ratio: {metadata['ratio']:.2f}:1")
    print(f"Method: {metadata['method']}")
    print(f"Template IDs: {metadata['template_ids']}")
    print(f"Timestamp: {metadata['timestamp']}")

  Node.js:
    const result = compressor.compress(text);

    console.log(`Original size: ${result.metadata.originalSize}`);
    console.log(`Compressed size: ${result.metadata.compressedSize}`);
    console.log(`Ratio: ${result.metadata.ratio.toFixed(2)}:1`);
    console.log(`Method: ${result.metadata.method}`);
    console.log(`Template IDs: ${result.metadata.templateIds}`);
    console.log(`Timestamp: ${result.metadata.timestamp}`);

  Rust:
    let (payload, method, metadata) = compressor.compress(text, None, None)?;

    println!("Original size: {}", metadata.original_size);
    println!("Compressed size: {}", metadata.compressed_size);
    println!("Ratio: {:.2}:1", metadata.ratio);
    println!("Method: {}", metadata.method);
    println!("Template IDs: {:?}", metadata.template_ids);
    println!("Timestamp: {}", metadata.timestamp);

--------------------------------------------------------------------------------

ERROR HANDLING

Python:

  from aura_compression import ProductionHybridCompressor

  try:
      compressor = ProductionHybridCompressor()
      compressed, method, metadata = compressor.compress(text)
      decompressed = compressor.decompress(compressed)
  except ValueError as e:
      print(f"Compression error: {e}")
  except Exception as e:
      print(f"Unexpected error: {e}")

Node.js:

  const { Compressor } = require('@aura/compression');

  try {
    const compressor = new Compressor();
    const result = compressor.compress(text);
    const decompressed = compressor.decompress(result.payload);
  } catch (error) {
    console.error(`Error: ${error.message}`);
  }

Rust:

  use aura_compression::{Compressor, AuraError};

  match compressor.compress(text, None, None) {
      Ok((payload, method, metadata)) => {
          match compressor.decompress(&payload) {
              Ok(decompressed) => println!("Success: {}", decompressed),
              Err(e) => eprintln!("Decompression error: {}", e),
          }
      }
      Err(e) => eprintln!("Compression error: {}", e),
  }

--------------------------------------------------------------------------------

PERFORMANCE TUNING

Disable audit logging for better performance:

  Python:
    compressor = ProductionHybridCompressor(enable_audit_logging=False)

  Node.js:
    const compressor = new Compressor({ enableAuditLogging: false });

  Rust:
    let compressor = Compressor::new(true, None, false, None, None);

Adjust compression preference margin:

  Python:
    compressor = ProductionHybridCompressor(aura_preference_margin=0.2)

  Node.js:
    const compressor = new Compressor({ auraPreferenceMargin: 0.2 });

  Rust:
    // Set in compressor struct directly
    compressor.aura_preference_margin = 0.2;

Pre-load templates for faster compression:

  Python:
    compressor = ProductionHybridCompressor(
        template_store_path="templates.json"
    )

  Node.js:
    const compressor = new Compressor({
      templateStorePath: 'templates.json'
    });

  Rust:
    let compressor = Compressor::new(
        true,
        Some("templates.json".to_string()),
        false,
        None,
        None
    );

--------------------------------------------------------------------------------

NEXT STEPS

For more information, see:
  - api.txt for complete API reference
  - docker.txt for Docker deployment
  - performance.txt for performance benchmarks
  - compliance.txt for GDPR/HIPAA/SOC2 compliance
